;; vim: set ft=clojure:

(ns-unmap *ns* 'namespace)

(require
  '[boot.file :as file]
  '[clojure.java.io :as io]
  '[clojure.string :as string :refer [join split trimr]])

(defn filter-vals
  [pred m]
  (reduce-kv #(if-not (pred %3) %1 (assoc %1 %2 %3)) {} m))

(def fixme "FIXME: document this")

(defn strip-indent
  [x]
  (let [[head & [z & _ :as tail]] (split (or x fixme) #"\n")
        indent (or (some->> z (re-find #"^ *") count) 0)
        strip  #(try (subs % indent) (catch Throwable _))]
    (->> tail (map strip) (list* head) (join "\n"))))

(defn multifn?
  [obj]
  (instance? clojure.lang.MultiFn obj))

(defn typeof
  [obj {:keys [dynamic macro]}]
  (cond dynamic        "dynamic"
        macro          "macro"
        (fn? obj)      "function"
        (multifn? obj) "multimethod"
        :else          "var"))

(defn link
  [sym]
  (-> (str sym)
      (.replaceAll "\\*" "")))

(defn emit-arglists
  [name arglists]
  (some->> arglists
           (map #(pr-str (list* name %)))
           (join " ")
           (format "```clojure\n%s\n```\n\n")))

(defn emit-var
  [link-path obj {:keys [name doc arglists argspecs file line] :as meta}]
  (let [src-link (format "%s%s#L%d" link-path file line)]
    (str (format "### [`%s`](%s)\n\n" name src-link)
         (format "_%s_\n\n" (typeof obj meta))
         (emit-arglists name arglists)
         (format "```\n%s\n```\n\n<hr>\n\n" (trimr (strip-indent doc))))))

(defn emit-vars
  [sections]
  (->> sections (map :vars) (reduce merge) vals (keep :md)))

(defn emit-ns
  [{:keys [name doc]}]
  (remove nil? [(when name (format "# %s\n\n" name))
                (when doc  (format "%s\n\n" (trimr (strip-indent doc))))]))

(defn emit-toc
  [xs]
  (->> xs (mapcat (fn [{:keys [title vars]}]
                    (-> (->> vars
                             (map #(format "[`%s`](#%s) " (first %) (link (first %))))
                             (cons (when title (format "#### %s\n\n" title)))
                             (remove nil?))
                        (concat ["\n\n"]))))))

(defn sections
  [x]
  (->> (assoc (:doc/toc x) nil {})
       (into (sorted-map))
       (reduce (fn [xs [k v]]
                 (->> (:vars x)
                      (filter-vals #(= k (:doc/section %)))
                      (into (sorted-map))
                      (assoc v :vars)
                      (conj xs)))
               [])))

(defn parse-ns
  [link-path x]
  (let [n (the-ns x)
        e #(let [m (meta %2)]
             (assoc m :md (emit-var link-path %1 m)))
        m (assoc (meta n)
                 :name x
                 :vars (->> (ns-publics n)
                            (reduce-kv #(assoc %1 %2 (e (var-get (ns-resolve n %2)) %3)) {})))
        s (sections m)]
    (->> (emit-vars s)
         (concat (list "<hr>\n\n"))
         (concat (emit-toc s))
         (concat (emit-ns m))
         (apply str))))

(def ^:dynamic *doc-ns-sym*)

(defn section*
  [title & syms]
  (let [id (gensym)
        ns *doc-ns-sym*
        n  (find-ns ns)]
    (alter-meta! n update-in [:doc/toc] assoc id {:title title})
    (doseq [s syms]
      (alter-meta! (ns-resolve n s) assoc :doc/section id))))

(defmacro section
  [title & syms]
  `(section* ~title ~@(map (partial list 'quote) syms)))

(defn generate-docs
  [ns out src-path ns-doc]
  (let [ns *doc-ns-sym*
        n  (find-ns ns)]
    (alter-meta! n assoc :doc ns-doc)
    (spit out (-> (.getParent (io/file out))
                  (file/relative-to src-path)
                  (str "/")
                  (parse-ns ns)))))

(defmacro namespace
  [ns ns-doc out src-path & sections]
  `(binding [*doc-ns-sym* '~ns]
     (alter-meta! (find-ns '~ns) assoc :doc/toc nil)
     (do ~@sections)
     (generate-docs '~ns ~out ~src-path ~ns-doc)))

(comment

  (def test-str  "asdf qwer
                 zxcv poiu")

  (namespace
    boot.core
    "The Boot core namespace, containing most of Boot's public API."
    "doc/boot.core.md"
    (format "../%s/boot/core/src/" boot.core/*boot-version*)

    (section
      "Configure Boot"
      *app-version*
      *boot-script*
      *boot-version*
      *boot-opts*
      *warnings*
      new-build-at
      last-file-change
      bootignore
      load-data-readers!)

    (section
      "Create Temp Directories"
      tmp-dir!
      cache-dir!)

    (section
      "TmpFile API"
      tmp-path
      tmp-dir
      tmp-file
      tmp-time)

    (section
      "Create Fileset"
      new-fileset)

    (section
      "Query Fileset For Files"
      tmp-get
      user-files
      input-files
      output-files)

    (section
      "Query Fileset For Directories"
      user-dirs
      input-dirs
      output-dirs)

    (section
      "Filter Fileset"
      input-fileset
      output-fileset)

    (section
      "Other Fileset Queries"
      ls
      fileset-namespaces)

    (section
      "Manipulate Fileset"
      commit!
      rm mv cp
      add-meta)

    (section
      "Add To Fileset"
      add-asset add-cached-asset mv-asset
      add-source add-cached-source mv-source
      add-resource add-cached-resource mv-resource)

    (section
      "Fileset Diffs"
      fileset-diff
      fileset-added
      fileset-removed
      fileset-changed)
    )

  (print test-str)

  (macroexpand '(section "asdf" "wqer" *boot-version*))
  (macroexpand '(namespace boo.asdf "asdf" "wqer" "asdfqwer"))

  (print (strip-indent test-str))

  (use 'clojure.pprint)

  (do (remove-ns 'foo.bar) (require 'foo.bar :reload))

  (defn link-path
    [src-path]
    (format "../../%s/%s" *boot-version* src-path))

  (require 'boot.core)
  (clojure.repl/pst)
  (->> 'foo.bar (parse-ns "../boot/core/src/") emit-toc (apply str) print)
  (->> 'foo.bar (parse-ns "../boot/core/src/") (spit "doc/foo.md"))
  (->> 'boot.core (parse-ns "../../2.5.2/boot/core/src/") (spit "doc/foo.md"))
  (->> 'boot.task.built-in (parse-ns "../../2.5.2/boot/core/src/") (spit "doc/foo.md"))

  (print (emit-var "../" "boot/pod/src/" a))
  (->> a :md print)

  )

