;; vim: set ft=clojure:

(require
  '[clojure.string :as string :refer [join split trimr]])

(defn filter-vals
  [pred m]
  (reduce-kv #(if-not (pred %3) %1 (assoc %1 %2 %3)) {} m))

(def fixme "FIXME: document this")

(defn strip-indent
  [x]
  (let [[head & [z & _ :as tail]] (split (or x fixme) #"\n")
        indent (or (some->> z (re-find #"^ *") count) 0)
        strip  #(try (subs % indent) (catch Throwable _))]
    (->> tail (map strip) (list* head) (join "\n"))))

(defn multifn?
  [obj]
  (instance? clojure.lang.MultiFn obj))

(defn typeof
  [obj {:keys [dynamic macro]}]
  (cond dynamic        "dynamic"
        macro          "macro"
        (fn? obj)      "function"
        (multifn? obj) "multimethod"
        :else          "var"))

(defn emit-arglists
  [name arglists]
  (some->> arglists
           (map #(pr-str (list* name %)))
           (join " ")
           (format "```clojure\n%s\n```\n\n")))

(defn emit-var
  [link-path obj {:keys [name doc arglists argspecs file line] :as meta}]
  (let [src-link (format "%s%s#L%d" link-path file line)]
    (str (format "### [`%s`](%s)\n\n" name src-link)
         (format "_%s_\n\n" (typeof obj meta))
         (emit-arglists name arglists)
         (format "```\n%s\n```\n\n<hr>\n\n" (trimr (strip-indent doc))))))

(defn emit-section
  [{:keys [title intro vars]}]
  (let [t (when title (format "## %s\n\n" title))
        i (when intro (format "%s\n\n" (trimr (strip-indent intro))))]
    (remove nil? (list* t i (map (comp :md second) vars)))))

(defn emit-ns
  [{:keys [name doc]}]
  (remove nil? [(when name (format "# %s\n\n" name))
                (when doc  (format "%s\n\n" (trimr (strip-indent doc))))]))

(defn emit-toc
  [xs]
  (->> xs (mapcat (fn [{:keys [title vars]}]
                    (->> vars
                         (map #(format "* %s\n" (first %)))
                         (cons (when title (format "#### %s\n\n" title)))
                         (remove nil?))))))

(defn sections
  [x]
  (->> (assoc (:doc/toc x) nil {})
       (into (sorted-map))
       (reduce (fn [xs [k v]]
                 (->> (:vars x)
                      (filter-vals #(= k (:doc/section %)))
                      (into (sorted-map))
                      (assoc v :vars)
                      (conj xs)))
               [])))

(defn parse-ns
  [link-path x]
  (let [n (the-ns x)
        e #(let [m (meta %2)]
             (assoc m :md (emit-var link-path %1 m)))
        m (assoc (meta n)
                 :name x
                 :vars (->> (ns-publics n)
                            (reduce-kv #(assoc %1 %2 (e (var-get (ns-resolve n %2)) %3)) {})))
        s (sections m)]
    s
    #_(->> (mapcat emit-section s)
         (concat (emit-ns m))
         (apply str))))

(comment

  (def test-str  "asdf qwer
                 zxcv poiu")

  (print test-str)

  (print (strip-indent test-str))

  (use 'clojure.pprint)

  (do (remove-ns 'foo.bar) (require 'foo.bar :reload))

  (defn link-path
    [src-path]
    (format "../../%s/%s" *boot-version* src-path))

  (require 'boot.core)
  (clojure.repl/pst)
  (->> 'foo.bar (parse-ns "../boot/core/src/") emit-toc pprint)
  (->> 'boot.core (parse-ns "../boot/core/src/") (spit "doc/foo.md"))
  (->> 'boot.core (parse-ns "../../2.5.2/boot/core/src/") (spit "doc/foo.md"))
  (->> 'boot.task.built-in (parse-ns "../../2.5.2/boot/core/src/") (spit "doc/foo.md"))

  (print (emit-var "../" "boot/pod/src/" a))
  (->> a :md print)

  )

